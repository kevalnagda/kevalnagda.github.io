<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-11-10T10:31:42+05:30</updated><id>http://localhost:4000/feed.xml</id><title type="html">Home</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>Keval Nagda</name></author><entry><title type="html">Dockerfile best practices</title><link href="http://localhost:4000/dockerfile-best-practices" rel="alternate" type="text/html" title="Dockerfile best practices" /><published>2020-11-09T13:30:08+05:30</published><updated>2020-11-09T13:30:08+05:30</updated><id>http://localhost:4000/dockerfile-best-practices</id><content type="html" xml:base="http://localhost:4000/dockerfile-best-practices">&lt;p&gt;Learning Docker and building Docker images from Dockerfile can be daunting at times, especially when you are a beginner. Following are a few important points to remember while dealing with Dockerfile and Docker images.&lt;/p&gt;

&lt;h2 id=&quot;minimize-the-number-of-steps-in-the-dockerfile&quot;&gt;Minimize the number of steps in the Dockerfile&lt;/h2&gt;

&lt;p&gt;Minimizing the number of steps in the Dockerfile not only helps you to improve the build but also significantly improves the pull performance.
Also, combining several steps into one line tends to create a single intermediary image instead of several i.e. each for one step.&lt;/p&gt;

&lt;h2 id=&quot;start-your-dockerfile-with-the-steps-that-are-least-likely-to-change&quot;&gt;Start your Dockerfile with the steps that are least likely to change&lt;/h2&gt;

&lt;p&gt;This is the best advice one can get while learning to build a Docker image from Dockerfile. Usually, the best practice is to structure your Dockerfile as follows:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Install the tools needed to build your application.&lt;/li&gt;
  &lt;li&gt;Install all the required dependencies, libraries and packages.&lt;/li&gt;
  &lt;li&gt;Finally, build your application.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;a-fairly-straightforward-approach-to-building-dockerfiles-in-an-iterative-manner-would-be-as-follows&quot;&gt;A fairly straightforward approach to building Dockerfiles in an iterative manner would be as follows:&lt;/h2&gt;

&lt;h3 id=&quot;1-pick-the-right-base-image&quot;&gt;1. Pick the right base image&lt;/h3&gt;

&lt;p&gt;Picking the right image can be confusing at times. Thus, you should experiment with the one that best suits your requirements. For example to build a simple python application, one can select &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python&lt;/code&gt; as their base image instead of selecting a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ubuntu&lt;/code&gt; base image and installing dependencies on top of it.&lt;/p&gt;

&lt;h3 id=&quot;2-go-to-the-shell-and-build-your-environment&quot;&gt;2. Go to the shell and build your environment&lt;/h3&gt;

&lt;p&gt;Building a docker image every time you make changes to your Dockerfile can be a hectic and time-consuming process. An alternative and efficient solution to this is to pull the preferred image locally and start a container in an interactive shell mode.&lt;/p&gt;

&lt;p&gt;Once the steps execute in the container perfectly as needed, you can add those instructions to the Dockerfile immediately.&lt;/p&gt;

&lt;h3 id=&quot;3-add-the-steps-to-your-dockerfile-and-build-your-image&quot;&gt;3. Add the steps to your Dockerfile and build your image&lt;/h3&gt;

&lt;p&gt;Stopping in middle, building and testing the docker image from the Dockerfile is also a crucial step. This step makes sure that you get the same desired results every time.&lt;/p&gt;

&lt;p&gt;This newly built image can then be used to instantiate a new container with an interactive shell mode to proceed with installation and set-up steps.&lt;/p&gt;

&lt;h3 id=&quot;4-repeat-steps-2-and-3&quot;&gt;4. Repeat steps 2 and 3&lt;/h3&gt;

&lt;p&gt;You might need to repeat steps 2 and 3 several times in order to thoroughly build a failproof Docker image and make sure that everything works fine as expected.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/builder/&quot;&gt;Dockerfile reference&lt;/a&gt; is a good place to look for common Dockerfile syntax, warnings and documentation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://takacsmark.com/dockerfile-tutorial-by-example-dockerfile-best-practices-2018/&quot;&gt;Dockerfile tutorial by example&lt;/a&gt;&lt;/p&gt;</content><author><name>Keval Nagda</name></author><category term="jekyll" /><category term="update" /><summary type="html">Learning Docker and building Docker images from Dockerfile can be daunting at times, especially when you are a beginner. Following are a few important points to remember while dealing with Dockerfile and Docker images. Minimize the number of steps in the Dockerfile Minimizing the number of steps in the Dockerfile not only helps you to improve the build but also significantly improves the pull performance. Also, combining several steps into one line tends to create a single intermediary image instead of several i.e. each for one step. Start your Dockerfile with the steps that are least likely to change This is the best advice one can get while learning to build a Docker image from Dockerfile. Usually, the best practice is to structure your Dockerfile as follows: Install the tools needed to build your application. Install all the required dependencies, libraries and packages. Finally, build your application. A fairly straightforward approach to building Dockerfiles in an iterative manner would be as follows: 1. Pick the right base image Picking the right image can be confusing at times. Thus, you should experiment with the one that best suits your requirements. For example to build a simple python application, one can select python as their base image instead of selecting a ubuntu base image and installing dependencies on top of it. 2. Go to the shell and build your environment Building a docker image every time you make changes to your Dockerfile can be a hectic and time-consuming process. An alternative and efficient solution to this is to pull the preferred image locally and start a container in an interactive shell mode. Once the steps execute in the container perfectly as needed, you can add those instructions to the Dockerfile immediately. 3. Add the steps to your Dockerfile and build your image Stopping in middle, building and testing the docker image from the Dockerfile is also a crucial step. This step makes sure that you get the same desired results every time. This newly built image can then be used to instantiate a new container with an interactive shell mode to proceed with installation and set-up steps. 4. Repeat steps 2 and 3 You might need to repeat steps 2 and 3 several times in order to thoroughly build a failproof Docker image and make sure that everything works fine as expected. Dockerfile reference is a good place to look for common Dockerfile syntax, warnings and documentation. References Dockerfile tutorial by example</summary></entry><entry><title type="html">Dockerfile tutorial</title><link href="http://localhost:4000/dockerfile" rel="alternate" type="text/html" title="Dockerfile tutorial" /><published>2020-11-09T13:30:08+05:30</published><updated>2020-11-09T13:30:08+05:30</updated><id>http://localhost:4000/dockerfile</id><content type="html" xml:base="http://localhost:4000/dockerfile">&lt;p&gt;Dockerfile is a text file that defines a set of commands or operations which aid you to build your own custom Docker image.&lt;/p&gt;

&lt;h2 id=&quot;why-would-you-want-to-use-a-dockerfile&quot;&gt;Why would you want to use a Dockerfile?&lt;/h2&gt;

&lt;p&gt;Well, there are times when existing docker images don’t satisfy your project needs and you want to do things differently. Docker helps you achieve this in an easy way, by just writing a Dockerfile!&lt;/p&gt;

&lt;h2 id=&quot;lets-dive-in&quot;&gt;Let’s dive in&lt;/h2&gt;

&lt;p&gt;We are aware that the available alpine image does not contain git, curl and vim installed by default. Thus, for learning purposes we create a new custom image based on alpine which contains git, curl and vim.&lt;/p&gt;

&lt;h3 id=&quot;1-create-a-dockerfile&quot;&gt;1. Create a Dockerfile&lt;/h3&gt;

&lt;p&gt;First of all, create an empty directory and an empty file inside that directory with the file name &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;touch Dockerfile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-define-a-base-image&quot;&gt;2. Define a base image&lt;/h3&gt;

&lt;p&gt;Every Dockerfile must start with a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FROM&lt;/code&gt; command. You can create an image from scratch, however there are a bunch of base images available which you can directly use by using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FROM&lt;/code&gt; command.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM alpine:3.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-add-instructions-to-install-packages&quot;&gt;3. Add instructions to install packages&lt;/h3&gt;

&lt;p&gt;Here we use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RUN&lt;/code&gt; instruction in Dockerfile to execute commands and install required packages.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RUN apk update
RUN apk add git
RUN apk add vim
RUN apk add curl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; It is ideal to execute multiple commands in a single &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RUN&lt;/code&gt; command as each instruction in Dockerfile creates an intermediary container.&lt;/p&gt;

&lt;p&gt;An efficient approach to the example would be as follows:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RUN apk update &amp;amp;&amp;amp; \
    apk add git &amp;amp;&amp;amp; \
    apk add vim &amp;amp;&amp;amp; \
    apk add curl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;4-building-the-image&quot;&gt;4. Building the image&lt;/h3&gt;

&lt;p&gt;You can build an image with the help of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker build&lt;/code&gt; command which automatically builds an image with nametag provided after &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-t&lt;/code&gt; flag as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;user_name&amp;gt;/&amp;lt;image_name&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker build -t kevalnagda/apline-smart:1.0 .
Sending build context to Docker daemon  2.048kB
Step 1/5 : FROM alpine:3.4
3.4: Pulling from library/alpine
c1e54eec4b57: Pull complete 
Digest: sha256:b733d4a32c4da6a00a84df2ca32791bb03df95400243648d8c539e7b4cce329c
Status: Downloaded newer image for alpine:3.4
 ---&amp;gt; b7c5ffe56db7
Step 2/5 : RUN apk update
 ---&amp;gt; Running in 42d39c87ae89
fetch http://dl-cdn.alpinelinux.org/alpine/v3.4/main/x86_64/APKINDEX.tar.gz
fetch http://dl-cdn.alpinelinux.org/alpine/v3.4/community/x86_64/APKINDEX.tar.gz
v3.4.6-316-g63ea6d0 [http://dl-cdn.alpinelinux.org/alpine/v3.4/main]
v3.4.6-160-g14ad2a3 [http://dl-cdn.alpinelinux.org/alpine/v3.4/community]
OK: 5973 distinct packages available
Removing intermediate container 42d39c87ae89
 ---&amp;gt; e5872a7d6fe7
Step 3/5 : RUN apk add git
 ---&amp;gt; Running in 335a8120b6b8
(1/6) Installing ca-certificates (20161130-r0)
(2/6) Installing libssh2 (1.7.0-r0)
(3/6) Installing libcurl (7.60.0-r1)
(4/6) Installing expat (2.2.0-r1)
(5/6) Installing pcre (8.38-r1)
(6/6) Installing git (2.8.6-r0)
Executing busybox-1.24.2-r14.trigger
Executing ca-certificates-20161130-r0.trigger
OK: 22 MiB in 17 packages
Removing intermediate container 335a8120b6b8
 ---&amp;gt; ef8d1eda0212
Step 4/5 : RUN apk add vim
 ---&amp;gt; Running in 48948ba27f5e
(1/5) Installing lua5.2-libs (5.2.4-r2)
(2/5) Installing ncurses-terminfo-base (6.0_p20171125-r0)
(3/5) Installing ncurses-terminfo (6.0_p20171125-r0)
(4/5) Installing ncurses-libs (6.0_p20171125-r0)
(5/5) Installing vim (7.4.1831-r3)
Executing busybox-1.24.2-r14.trigger
OK: 54 MiB in 22 packages
Removing intermediate container 48948ba27f5e
 ---&amp;gt; 614ca6706e18
Step 5/5 : RUN apk add curl
 ---&amp;gt; Running in cccca59dceac
(1/1) Installing curl (7.60.0-r1)
Executing busybox-1.24.2-r14.trigger
OK: 54 MiB in 23 packages
Removing intermediate container cccca59dceac
 ---&amp;gt; 7f6efe76a85e
Successfully built 7f6efe76a85e
Successfully tagged kevalnagda/apline-smart:1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can check the new image by executing the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker images&lt;/code&gt; command as follows:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker images
REPOSITORY                TAG                 IMAGE ID            CREATED             SIZE
kevalnagda/apline-smart   1.0                 7f6efe76a85e        4 minutes ago       48.7MB
alpine                    3.4                 b7c5ffe56db7        21 months ago       4.82MB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you look at the output of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker build&lt;/code&gt; command, you would notice that there are 5 steps, namely Step 1/5, Step 2/5, Step 3/5 and so on…&lt;/p&gt;

&lt;p&gt;The reason for this is that docker builds images by executing the instructions mentioned in the Dockerfile one at a time. Another thing to note here is that with every step in the build process, Docker will create an intermediary image for that particular step. This is called image layering and its main advantage lies in image caching.&lt;/p&gt;

&lt;p&gt;If you were to rebuild the image, you would notice that the build was faster as compared to the build before that since the build was done from the cache. This behaviour makes our life a lot easier.&lt;/p&gt;

&lt;h2 id=&quot;dockerfile-instructions&quot;&gt;Dockerfile instructions&lt;/h2&gt;

&lt;h3 id=&quot;1-from&quot;&gt;1. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FROM&lt;/code&gt;:&lt;/h3&gt;
&lt;p&gt;Let’s set a base image in the Dockerfile. The instruction is in the form of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FROM &amp;lt;base_image&amp;gt;[:tag]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;2-run&quot;&gt;2. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RUN&lt;/code&gt;:&lt;/h3&gt;
&lt;p&gt;Let’s you run commands and it’s one of the most used instructions in Dockerfile.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RUN&lt;/code&gt; instruction has two forms, where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RUN &amp;lt;command&amp;gt;&lt;/code&gt; is called the shell form and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]&lt;/code&gt; is called the exec form.&lt;/p&gt;

&lt;h3 id=&quot;3-copy&quot;&gt;3. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COPY&lt;/code&gt;:&lt;/h3&gt;
&lt;p&gt;Helps you copy files and directories to your Docker image. The instruction is in the form of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COPY &amp;lt;src&amp;gt; &amp;lt;dest&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;4-add&quot;&gt;4. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADD&lt;/code&gt;:&lt;/h3&gt;
&lt;p&gt;Helps you add files and directories to your Docker image. The instruction is in the form of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADD &amp;lt;src&amp;gt; &amp;lt;dest&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; The main difference between &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ADD&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;COPY&lt;/code&gt; command is that the former one is more advanced and has additional features like pulling files from url sources, recognizing and handling a lot more file formats than the later one.&lt;/p&gt;

&lt;h3 id=&quot;5-env&quot;&gt;5. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ENV&lt;/code&gt;:&lt;/h3&gt;
&lt;p&gt;Let’s you define environment variables in Dockerfile.&lt;/p&gt;

&lt;h3 id=&quot;6-workdir&quot;&gt;6. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WORKDIR&lt;/code&gt;:&lt;/h3&gt;
&lt;p&gt;A way to define the working directory for your project.&lt;/p&gt;

&lt;h3 id=&quot;7-expose&quot;&gt;7. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EXPOSE&lt;/code&gt;:&lt;/h3&gt;
&lt;p&gt;It informs you about the exposed ports your application is listening on.&lt;/p&gt;

&lt;h3 id=&quot;8-cmd&quot;&gt;8. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CMD&lt;/code&gt;:&lt;/h3&gt;
&lt;p&gt;It lets you specify which component is to be run by your image on execution of the container. The format is given as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;, ...]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;One important thing to note here is that there should only be &lt;strong&gt;one &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CMD&lt;/code&gt; instruction&lt;/strong&gt; in a Dockerfile. If more than one &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CMD&lt;/code&gt; instruction is present then only the last one will be used during execution.&lt;/p&gt;

&lt;h3 id=&quot;9-entrypoint&quot;&gt;9. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ENTRYPOINT&lt;/code&gt;:&lt;/h3&gt;
&lt;p&gt;When the main executable is used in this instruction then the parameters provided in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CMD&lt;/code&gt; instruction will be added as parameters to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ENTRYPOINT&lt;/code&gt; instruction. Example:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ENTRYPOINT [&quot;git&quot;]
CMD [&quot;--help&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://takacsmark.com/dockerfile-tutorial-by-example-dockerfile-best-practices-2018/&quot;&gt;Dockerfile tutorial by example&lt;/a&gt;&lt;/p&gt;</content><author><name>Keval Nagda</name></author><category term="jekyll" /><category term="update" /><summary type="html">Dockerfile is a text file that defines a set of commands or operations which aid you to build your own custom Docker image.</summary></entry><entry><title type="html">Windows Subsystem for Linux (WSL)</title><link href="http://localhost:4000/WSL" rel="alternate" type="text/html" title="Windows Subsystem for Linux (WSL)" /><published>2020-11-04T13:30:08+05:30</published><updated>2020-11-04T13:30:08+05:30</updated><id>http://localhost:4000/WSL</id><content type="html" xml:base="http://localhost:4000/WSL">&lt;p&gt;WSL is a tool that enables users to run Bash and core Linux command-line tools on Windows. Ain’t that awesome?!&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;WSL has two different versions namely WSL and WSL 2 where the later one has better overall performance and usability.&lt;/p&gt;

&lt;p&gt;In this tutorial we aim to install WSL 2 instead of WSL.&lt;/p&gt;

&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;/h2&gt;

&lt;h4 id=&quot;enable-the-windows-subsystem-for-linux&quot;&gt;Enable the Windows Subsystem for Linux&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/wsl/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;check-system-requriements&quot;&gt;Check system requriements&lt;/h4&gt;

&lt;p&gt;There are specific system requirements that need to be fulfilled in order to run WSL 2. A detailed description can be found &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/wsl/install-win10#requirements&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To check your version and build number, select &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Windows logo key + R&lt;/code&gt;, type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;winver&lt;/code&gt;, select &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OK&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/wsl/2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;enable-virtual-machine-feature&quot;&gt;Enable Virtual Machine feature&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/wsl/3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;download-and-run-the-linux-kernel-update-package&quot;&gt;Download and run the Linux kernel update package&lt;/h4&gt;

&lt;p&gt;Download the latest package from &lt;a href=&quot;https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi&quot;&gt;WSL2 Linux kernal update package for x64 machines&lt;/a&gt; and run it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/wsl/4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;set-wsl-2-as-your-default-version&quot;&gt;Set WSL 2 as your default version&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wsl --set-default-version 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/wsl/5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;install-linux-distribution&quot;&gt;Install Linux distribution&lt;/h4&gt;

&lt;p&gt;Install your favourite Linux distro from Microsoft Store.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/wsl/6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;setting-up-new-distribution&quot;&gt;Setting up new distribution&lt;/h4&gt;

&lt;p&gt;On launching the new Linux distribution, a console window will open and perform some setup operations under the hood for the first time. Subsequent launches should be faster.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/wsl/7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Yay!! You’re good to go. Developers can further can setup &lt;a href=&quot;https://code.visualstudio.com/docs/remote/wsl&quot;&gt;Visual Studio Code Remote&lt;/a&gt; to edit files and develop applications on WSL from Windows.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/wsl/install-win10&quot;&gt;Windows Subsystem for Linux Installation Guide for Windows 10&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Keval Nagda</name></author><category term="jekyll" /><category term="update" /><summary type="html">WSL is a tool that enables users to run Bash and core Linux command-line tools on Windows. Ain’t that awesome?! Introduction WSL has two different versions namely WSL and WSL 2 where the later one has better overall performance and usability. In this tutorial we aim to install WSL 2 instead of WSL. Installation Enable the Windows Subsystem for Linux dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart Check system requriements There are specific system requirements that need to be fulfilled in order to run WSL 2. A detailed description can be found here. To check your version and build number, select Windows logo key + R, type winver, select OK. Enable Virtual Machine feature dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart Download and run the Linux kernel update package Download the latest package from WSL2 Linux kernal update package for x64 machines and run it. Set WSL 2 as your default version wsl --set-default-version 2 Install Linux distribution Install your favourite Linux distro from Microsoft Store. Setting up new distribution On launching the new Linux distribution, a console window will open and perform some setup operations under the hood for the first time. Subsequent launches should be faster. Conclusion Yay!! You’re good to go. Developers can further can setup Visual Studio Code Remote to edit files and develop applications on WSL from Windows. Reference Windows Subsystem for Linux Installation Guide for Windows 10</summary></entry><entry><title type="html">HP Envy x360 13 review</title><link href="http://localhost:4000/hp-envy-x360-review" rel="alternate" type="text/html" title="HP Envy x360 13 review" /><published>2020-11-03T13:30:08+05:30</published><updated>2020-11-03T13:30:08+05:30</updated><id>http://localhost:4000/hp-envy-x360-review</id><content type="html" xml:base="http://localhost:4000/hp-envy-x360-review">&lt;p&gt;The Envy x360 13 series being a mid-range 2-in-1 convertible laptop beats most of the other laptops in the league. It is positioned above the cheaper Pavilion x360 range and below the Spectre flagship. However, it performs surprisingly close to a Spectre.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/envyx360/laptop.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;case&quot;&gt;Case&lt;/h2&gt;

&lt;p&gt;The Envy x360 is built with a metal chassis material with texture and build quality similar to the one used in 2019 Spectre x360 13 models. The lid is flexible enough to be twisted, however, the rigidity of hinges are likely to teeter over time and thus, could have been better.&lt;/p&gt;

&lt;p&gt;The 2020 version of Envy x360 13 is much smaller compared to the 2019 version. The weight 1.3kg remains almost the same as the new design is slightly thicker than the former ones. However, the model is light and compact enough for its use in tablet mode.&lt;/p&gt;

&lt;h2 id=&quot;input&quot;&gt;Input&lt;/h2&gt;

&lt;p&gt;The keyboard typing experience is relatively good and key positioning is much better compared to other laptops. Keys like Caps Lock, Mute, Microphone, Power and Camera have individual LED indicators on them which lets you know if those keys toggled on or off. Also, the keyboard consists of two levels of white backlighting which helps you to recognize the key in a dark environment.&lt;/p&gt;

&lt;p&gt;The touchpad is again slightly larger than the one on the 2019 Spectre x360 13. Cursor movements feel a bit of lagging, but in turn, provides good precision control. Feedback on the integrated click could have been better.&lt;/p&gt;

&lt;h2 id=&quot;display&quot;&gt;Display&lt;/h2&gt;

&lt;p&gt;The Envy x360 13’s touch -screen display measures 13.3 inches diagonally, common screen size for ultraportables. It’s only available in full HD i.e. 1,920 by 1,080-pixel resolution, where a 4K resolution or OLED display option which could have been much better. Response time is average with crisp contrast and colours with 60Hz refresh rate panel.&lt;/p&gt;

&lt;p&gt;HP offers three brightness options at the configuration: 300 nits, 400 nits, and 1000 nits based on personal preference and the environment of use. Brightness is evenly distributed across the screen, however a light-moderate uneven backlight bleeding along the bottom edge may be observed in some cases.&lt;/p&gt;

&lt;p&gt;The model comes with an HP MPP2.0 stylus/pen, but cannot be stored on the laptop itself. A stylus can be very useful in the tablet mode or where a direct interaction to the screen is required. However, I feel touchscreen response is much better and faster as compared to the stylus.&lt;/p&gt;

&lt;h2 id=&quot;performance&quot;&gt;Performance&lt;/h2&gt;

&lt;p&gt;HP offers a wide range of options in processor selection. One can have 4/4 core/thread Ryzen 3 4300U, 6/6 core/thread Ryzen 5 4500U or 8/8 core/thread Ryzen 7 7400U in the AMD category. It also provides a 4/8 core/thread i7 -1065G7 option for Intel users. The model comes with integrated Radeon RX Vega or Iris Plus graphics and no other discrete GPU options.&lt;/p&gt;

&lt;p&gt;CPU performance is excellent considering that Ryzen 5 4500U is AMD’s budget-to-midrange offering. Additionally, multi-thread performance is about 10-15 percent faster than the pricier Intel Core i7-1065G7 model.&lt;/p&gt;

&lt;p&gt;One major disadvantage one might come across is that the Envy x360 13 model comes with a soldered RAM and is not upgradeable. RAM is soldered at 8 GB to 16 GB of DDR4-3200, but the memory runs in dual-channel mode.&lt;/p&gt;

&lt;p&gt;Coming to the storage, my model consists of 512 GB Toshiba SSD which is a good option for budget NVMe drives. The more expensive Samsung PM981 series can offer over two to three times the sequential writes offered by our Toshiba SSD.&lt;/p&gt;

&lt;p&gt;Battery life is interestingly long despite the small 51 Wh Internal battery. The battery runs for almost 10-12 hours for normal tasks before automatic shutdown which is much better than the Apple MacBook Pro 13. It takes about 1.5 to 2 hours to completely charge the with the AC adapter. The model even comes with a USB-C port and can be charged via that too.&lt;/p&gt;

&lt;h2 id=&quot;final-verdict&quot;&gt;Final Verdict&lt;/h2&gt;

&lt;p&gt;The AMD backed 2020 Envy x360 13 looks and performs very well for the relatively low price its available for. Some hardware limitations may prevent it from being the best convertible model out there. Nevertheless, there is no other model that balances performance, weight, build quality and price better than the 2020 Envy x360 13 at the moment.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.notebookcheck.net/2020-HP-Envy-x360-13-Convertible-2-in-1-Review-Ryzen-5-Beats-a-Core-i7.477589.0.html&quot;&gt;2020 HP Envy x360 13&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Keval Nagda</name></author><category term="jekyll" /><category term="update" /><summary type="html">The Envy x360 13 series being a mid-range 2-in-1 convertible laptop beats most of the other laptops in the league. It is positioned above the cheaper Pavilion x360 range and below the Spectre flagship. However, it performs surprisingly close to a Spectre.</summary></entry><entry><title type="html">Getting started with Docker</title><link href="http://localhost:4000/getting-started-with-docker" rel="alternate" type="text/html" title="Getting started with Docker" /><published>2020-11-02T18:30:08+05:30</published><updated>2020-11-02T18:30:08+05:30</updated><id>http://localhost:4000/getting-started-with-docker</id><content type="html" xml:base="http://localhost:4000/getting-started-with-docker">&lt;p&gt;&lt;img src=&quot;/assets/img/docker/docker-image.jpeg&quot; alt=&quot;Docker&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;what-is-docker&quot;&gt;What is Docker?&lt;/h2&gt;

&lt;p&gt;Docker is a software tool that helps you build, distribute, deploy and run applications inside an isolated sandbox called container.&lt;/p&gt;

&lt;h2 id=&quot;why-use-docker-over-vitual-machine&quot;&gt;Why use Docker over Vitual Machine?&lt;/h2&gt;

&lt;p&gt;Docker uses containers for all of its operations and containers consume user space of an operating system. In simple terms, container is just a set of processes that are isolated from the rest of the system.&lt;/p&gt;

&lt;p&gt;However, a Virtual Machine (VM) consumes user space as well as kernel space of an operating system for all of its operations. Each VM consists of an operating system and apps. Internally VMs use virtualized hardware, but share system hardware resources from the host operating system.&lt;/p&gt;

&lt;h2 id=&quot;terminology&quot;&gt;Terminology&lt;/h2&gt;

&lt;p&gt;There is a bunch of Docker-specific jargon associated with the Docker ecosystem. So let’s understand some important terms.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Docker Image:&lt;/strong&gt; A blueprint of the application that helps us run containers.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Docker Container:&lt;/strong&gt; Created from Docker image to run applications.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Docker Daemon:&lt;/strong&gt; Background service running on host operating system that manages building, running and distribution of Docker Containers.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Docker Client:&lt;/strong&gt; A command line tool that allows user to interact with the Docker Daemon.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Docker Hub:&lt;/strong&gt; A pool of all available Docker Images where one can host their own Docker Images in the registries and pull other users’ Docker Images.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;/h2&gt;

&lt;p&gt;The &lt;em&gt;getting started&lt;/em&gt; guide on Docker website has detailed instructions for setting up Docker on &lt;a href=&quot;https://docs.docker.com/docker-for-mac/install/&quot;&gt;Mac&lt;/a&gt;, &lt;a href=&quot;https://docs.docker.com/engine/install/ubuntu/&quot;&gt;Linux&lt;/a&gt; and &lt;a href=&quot;https://docs.docker.com/docker-for-windows/install/&quot;&gt;Windows&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Installation can be verified by running the following command:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@Keval:/home/keval# docker run hello-world
Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
0e03bdcc26d7: Pull complete 
Digest: sha256:8c5aeeb6a5f3ba4883347d3747a7249f491766ca1caa47e5da5dfcf6b9b717c0
Status: Downloaded newer image for hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;playing-with-busybox&quot;&gt;Playing with Busybox&lt;/h2&gt;

&lt;p&gt;To get our hands dirty, let’s run a &lt;a href=&quot;https://en.wikipedia.org/wiki/BusyBox&quot;&gt;Busybox&lt;/a&gt; container on our system to understand &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run&lt;/code&gt; command.&lt;/p&gt;

&lt;p&gt;To get started, we first need to pull the busybox image from the Docker registry.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@Keval:/home/keval# docker pull busybox
Using default tag: latest
latest: Pulling from library/busybox
9758c28807f2: Pull complete 
Digest: sha256:a9286defaba7b3a519d585ba0e37d0b2cbee74ebfe590960b0b1d6a5e97d1e1d
Status: Downloaded newer image for busybox:latest
docker.io/library/busybox:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker pull&lt;/code&gt; command fetches the required image and stores it to our system.&lt;/p&gt;

&lt;p&gt;To view a list of all images on your system, use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker images&lt;/code&gt; command as follows:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@Keval:/home/keval# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
busybox             latest              f0b02e9d092d        2 weeks ago         1.23MB
hello-world         latest              bf756fb1ae65        10 months ago       13.3kB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we can run a Docker container based on this image by executing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run&lt;/code&gt; command in the terminal.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@Keval:/home/keval# docker run busybox
root@Keval:/home/keval# 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;However, we see no output. Why? Well, when we perform &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run&lt;/code&gt; command in terminal, the Docker Client finds the image (busybox in our case) loads up a container and then runs a commands in that container. While executing the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run&lt;/code&gt; command above we did not give any command and thus, in this case the container ran an empty &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;run&lt;/code&gt; command and exited.&lt;/p&gt;

&lt;p&gt;We should try to echo something from the container.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@Keval:/home/keval# docker run busybox echo &quot;Busybox says hi&quot;
Busybox says hi
root@Keval:/home/keval# 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Okay good, we see the echo message. Now to view a list of all the running/active containers we use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker ps&lt;/code&gt; command. However, we have no running containers and this command would result in a blank output. A more useful and powerful variant of this is the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker ps -a&lt;/code&gt; command which shows us a list of all the containers, be it in running  or exited state.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@Keval:/home/keval# docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                          PORTS               NAMES
907bef05f9bd        busybox             &quot;echo 'Busybox says …&quot;   26 seconds ago       Exited (0) 24 seconds ago                           wonderful_archimedes
1f6a478c7b38        busybox             &quot;sh&quot;                     About a minute ago   Exited (0) About a minute ago                       happy_bartik
d45fa34b3d93        hello-world         &quot;/hello&quot;                 26 minutes ago       Exited (0) 26 minutes ago                           sad_goldstine
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It also possible for one to execute more than one command in a container. Running the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run&lt;/code&gt; command with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-it&lt;/code&gt; flag provides us with an interactive tty (TeleTYpewriter) which allows us to execute as many commands we want in a container.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@Keval:/home/keval# docker run -it busybox sh
/ # ls
bin   dev   etc   home  proc  root  sys   tmp   usr   var
/ # uptime
 05:55:22 up  1:23,  0 users,  load average: 1.33, 0.81, 0.74
/ # exit
root@Keval:/home/keval# 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now everytime we execute the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run&lt;/code&gt; command, a new container is created which stays in the system storage if not removed. Thus, it is important to clean up the space by removing unwanted containers using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker rm&lt;/code&gt; command.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@Keval:/home/keval# docker rm 78eac55cb3a3
78eac55cb3a3
root@Keval:/home/keval# 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Deleting containers by copypasting container IDs can be tedious at times and thus, you can delete a bunch of containers in single go by -&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@Keval:/home/keval# docker rm $(docker ps -a -q -f status=exited)
907bef05f9bd
1f6a478c7b38
d45fa34b3d93
root@Keval:/home/keval# 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-q&lt;/code&gt; flag is used to return only numeric IDs and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-f&lt;/code&gt; flag filters output based on the conditions provided (in our case containers with status equal to exited).&lt;/p&gt;

&lt;p&gt;Similarly, images can also be deleted using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker rmi&lt;/code&gt; command.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@Keval:/home/keval# docker rmi busybox
Untagged: busybox:latest
Untagged: busybox@sha256:a9286defaba7b3a519d585ba0e37d0b2cbee74ebfe590960b0b1d6a5e97d1e1d
Deleted: sha256:f0b02e9d092d905d0d87a8455a1ae3e9bb47b4aa3dc125125ca5cd10d6441c9f
Deleted: sha256:d2421964bad195c959ba147ad21626ccddc73a4f2638664ad1c07bd9df48a675
root@Keval:/home/keval# 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;There is more to Docker than just a bunch of basic commands covered above. However, I hope this blog got you interested in the Docker.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://docker-curriculum.com/&quot;&gt;Docker for beginners&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Keval Nagda</name></author><category term="jekyll" /><category term="update" /><summary type="html"></summary></entry></feed>